---
layout: single
title: "[CS:APP] Chap2 A Representing and Manipulating Information(5)-Summary"
categories: ComputerSystems
tag: [CS, CSAPP]
toc: true
---

## 2.5 Summary

 컴퓨터는 정보를 비트로 인코딩하며, 이는 일반적으로 바이트의 시퀀스로 구성된다. Integer, Real numbers, Character strings을 표현하기 위해 서로 다른 인코딩 방식이 사용된다. 다양한 컴퓨터 모델은 숫자를 인코딩하고 multi-byte data를 정렬하는 방식에서 서로 다른 규칙을 따른다.

 C언어는 워드 크기와 숫자 인코딩 방식이 다양한 구현을 수용할 수 있도록 설계되었다. 64비트 워드 크기를 가진 머신이 점점 더 일반화되면서, 약 30년간 시장을 지배했던 32비트 머신을 대체하고 있다. 64비트 머신은 32비트로 컴파일된 프로그램을 실행할 수 있으므로, 이 책에서는 32비트와 64비트 프로그램의 차이에 초점을 맞췄다. 64비트 프로그램의 장점은 32비트 프로그램의 4GB 주소 제한을 초과할 수 있다는 점이다.

 대부분의 머신은 부호 있는 숫자를 2의 보수(Two's-Complement)방식으로, 부동 소수점 숫자를 IEEE 754 표준 방식으로 인코딩한다. 비트 수준에서 이러한 인코딩과 산술 연산의 수학적 특성을 이해하는 것은 숫자 값의 전체 범위에서 올바르게 작동하는 프로그램을 작성하는 데 중요한 역할을 한다.

 같은 크기의 부호 있는 정수와 부호 없는 정수 간의 캐스팅에서 대부분 C 구현은 기본 비트 패턴을 변경하지 않는 규칙을 따른다. 2의 보수를 사용하는 머신에서는 이러한 동작이 T2U<sub>w</sub>와 U2T<sub>w</sub> 함수로 설명된다. C의 암시적 캐스팅은 많은 프로그래머가 예상하지 못하는 결과를 초래하며, 이는 종종 프로그램 버그로 이어진다.

 인코딩 길이가 유한하기 때문에, 컴퓨터 산술은 기존의 정수 및 실수 산술과는 매우 다른 특성을 가진다. 유한 길이는 표현 범위를 초과할 경우 오버플로우를 발생시킬 수 있다. 부동소수점 값은 0.0에 너무 가까워지면 언더플로우를 발생시키며, 값이 0으로 변경된다.

 C와 대부분의 다른 프로그래밍 언어에서 구현된 유한 정수 산술은 실제 정수 산술과 비교해 몇가지 특이한 특성을 가진다. 예를 들어 표현식 X x X는 오버플로우로 인해 음수가 될 수 있다. 그럼에도 불구하고 부호 없는 산술과 2의 보수 산술은 결합법칙, 교환법칙, 분배법칙 등 정수 산술의 다른 속성을 만족한다. 이러한 속성 덕분에 컴파일러는 많은 최적화를 수행할 수 있다. 예를 들어 7 x X를 (x<<3)-x로 대체할 수 있다. 곱셈 연산은 많은 클록 사이클이 사용되므로, 클록사이클이 한번 사용되는 시프트 연산과 덧셈연산을 이용하여 최적화가 가능하다.

 또한 비트 수준 연산과 산술 연산을 결합해 활용하는 여러가지 방법들을 보았다. 예를 들어, 2의 보수 산술에서 x+1은 -x와 동등하다. 또 다른 예로, w-k개의 0과 k개의 1로 구성된 비트 패턴을 생성하려 한다 가정을 해보겠다. 이러한 비트 패턴은 마스킹 연산에 유용하다. 이 패턴은 (1 << k) - 1 이라는 C 표현식으로 생성할 수 있으며, 이는 해당 비트 패턴의 값이 2<sup>k</sup> - 1 임을 활용한다. 예를 들어, (1 << 8) - 1 표현식은 비트 패턴 0xFF를 생성한다.

 부동소수점 표현은 X x 2<sup>y</sup>형식의 숫자를 인코딩하여 실수를 근사한다. IEEE 754 표준은 단정밀도(32비트)와 배정밀도(64비트)가 가장 일반적이며, 여러 가지 정밀도를 제공한다. IEEE 부동소수점은 +∞,−∞, NaN과 같은 특수 값을 나타내는 표현도 제공한다.

 부동소수점 산술은 제한된 범위와 정밀도를 가지며, 결합법칙과 같은 일반적인 수학적 특성을 따르지 않기 때문에 매우 신중하게 사용해야 한다.
