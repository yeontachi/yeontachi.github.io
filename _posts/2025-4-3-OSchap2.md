---
layout: single
title: "[OS] 프로세스 Process Concept (1)"
categories: OS
tag: [CS, OS]
toc: true
---

## Process Concept

 - **운영체제가 실행하는 프로그램?** 
    - **Batch system** : 작업(job) 단위로 프로그램을 실행한다.
    - **Time-shared system** : 여러 사용자 프로그램(Task)을 동시에 실행한다.

 > 즉, 운영체제는 여러 개의 프로그램을 다양한 방식으로 실행하고 관리하는 역할을 한다.

 - **프로그램(Program)이란?**
    - 디스크에 저장된 **정적인 코드 집합**
    - 예: .exe, .out, .sh 같은 실행 파일을 의미한다.
    - 수동적인 존재이며, 실행되지 않으면 아무 일도 하지 않는다.

 > 프로그램은 단지 명령어의 집합일 뿐이며, 메모리에 올라가서 실행되기 전까지는 프로세스가 아니다.

 - **프로세스(Process)란?**
    - **실행 중인 프로그램**을 의미한다.
    - 즉, 프로그램의 인스턴스가 메모리에 올라가서 실행되고 있는 상태
    - 운영체제가 해당 프로세스를 관리하며 필요한 리소스를 할당한다.

 - **UNIX 프로세스의 특징**
    - 활성 상태(Active Entity):
        - Program Counter(PC) : 다음 실행할 명령어의 주소를 가리킨다.
        - 자원(Resource) : 메모리, 파일, 소켓, 프로세서 시간 등 할당된다.

    - 프로세스는 다음과 같은 정보로 구성된다. : 
        - 가상 주소 공간(Virtual Address Space) : 코드, 데이터, 힙, 스택 등 포함
        - 제어 정보(Control Information) : 프로세스의 상태, 레지스터 값, 스케줄링 정보 등이 PCB(Process Control Block)에 저장된다.

 > 프로세스는 OS가 직접 관리하는 실행 단위이며, 운영체제는 수많은 프로세스들을 동시에 다루고 있다.

## 프로세스 실행

## 프로세스 상태

 프로세스 실행 중에 **상태(state)**가 변한다. 운영체제는 각 상태에서 어떤 작업을 하고 있는지를 구분해서 효율적인 CPU 관리와 자원 스케줄링을 한다.

 - **New** : 프로세스가 생성 중인 초기 상태(아직 준비되지 않음)
 - **Ready** : 실행할 준비가 된 상태, CPU 할당 대기 중
 - **Running** : CPU에서 명령어 실행 중인 상태
 - **Waiting(Blocked)** : 입출력 등 특정 이벤트 대기 중(예: 파일 읽기, 사용자 입력 등)
 - **Terminated** : 실행 완료 or 오류 발생으로 종료된 상태

![Alt text](/assets/OSimages/process_states.png)

### Time Slice(타임 슬라이스)
 - Time Slice는 하나의 프로세스가 CPU를 **연속으로 사용할 수 있는 시간 제한**이다.
 - 시간 단위 보통 수 밀리초 (에: 10ms, 50ms 등).
 - **타임 슬라이스가 끝나면 강제로 CPU를 반환하고 Ready 상태로 돌아간다.**

 > 이 메커니즘 덕분에 여러 프로세스가 공정하게 CPU를 나눠 쓰며, 한 프로세스가 독점하지 못하게 된다.

### Waiting -> Running ?
 - 입출력 등으로 인해 **Waiting 상태**에 있던 프로세스가 다시 이벤트(예: I/O 완료)받고 깨어날 경우, 운영체제는 해당 프로세스를 **Ready 상태**로 되돌린다. 즉 바로 Running으로 올리지 않는다. 
 - 바로 Running으로 올리지 않는 이유는 Ready Queue에 이미 있는 프로세스들보다 먼저 CPU를 점유하면 **비공정한 스케줄링**이 되기 때문이다. Time Slice를 건너뛰고 **CPU를 독점하는 것을 방지**하기 위함이다.

### CPU Idle 
 **Idle 상태**란, CPU가 현재 수행할 작업(프로세스)이 없어 놀고 있는 상태를 말한다. 즉, 운영체제가 스케줄링 가능한 Ready 상태의 프로세스를 하나도 갖고 있지 않을 때, CPU는 어떤 명령어도 실행하지 못하고 대기 상태에 놓인다. 이 상태를 Idle상태라고 한다.

 대부분의 OS는 특별한 idle 프로세스를 준비한다. 이 프로세스는 CPU가 놀고 있을 때 실행되며 무의미한 루프 혹은 저전력 상태 진입을 수행한다. 예시로 리눅스 커널은 PID 0번을 idle task로 사용한다.


## PCB(Process Control Block)
 **PCB**는 운영체제가 각 프로세스를 관리하기 위해 사용하는 데이터 구조로, 하나의 프로세스마다 고유하게 생성되며, 그 프로세스의 모든 중요한 정보를 담고 있다. 운영체제가 스케줄링, 문맥 교환(context switch), 자원 할당 등을 수행할 때 이 PCB 정보를 기반으로 처리한다.

### PCB가 담고 있는 정보
 - **Process State(프로세스 상태)** : 프로세스의 현재 상태를 나타냄
 - **Program Counter(PC)** : 다음에 실행할 명령어의 메모리 주소를 나타낸다. 문맥 교환 시 이 값을 저장했다가 복원한다.
 - **CPU Registers** : 실행 중인 프로세스가 사용하는 레지스터 값들
 - **CPU scheduling information** : 프로세스를 언제 실행할지를 결정하기 위한 정보
 - **Memory Management Informatioin** : 이 프로세스가 사용하는 메모리 관련 정보
 - **Accounting Information** : 프로세스의 실행 시간이나 자원 사용량 추적
 - **I/O Status Information** : 해당 프로세스가 사용하는 입출력 장치 상태

![Alt text](/assets/OSimages/PCBOS.png)

## 프로세스 생성(Process Creation)
- **프로세스 생성의 흐름**
    - 운영체제에서 부모 프로세스가 자식 프로세스를 생성 -> 프로세스 트리 형성
    - UNIX 시스템에서는 다음의 시스템 호출로 구현된다.
        - **fork()** : 부모의 메모리 공간을 복제하여 자식 생성
        - **exec()** : 자식의 메모리 공간을 새 프로그램으로 교체

- **PID(Process ID)** : 운영체제는 각 프로세스에 고유한 PID를 부여하여 이를 통해 제어하거나 추적한다.

![Alt text](/assets/OSimages/ProcessTree.jpg)

- **프로세스 계층 구조(Solaris)**
    - **PID 0** : sched(swapper)
        - 커널에서 최초로 동작하는 프로세스, 커널의 일부로 디스크에 존재하지 않는다.
        - 메모리 상주, 프로세스 스케줄링을 담당하며 나머지 커널 스레드들을 직접 생성한다.

    - **PID 2,3** : pageout, fsflush(커널 스레드)
        - Pageout : 가상 메모리 시스템에서 페이지가 부족할 때 디스크로 내보내는 역할을 한다. 자주 사용되지 않는 메모리를 스왑 아웃(Swap Out)한다.
        - fsflush : 파일 시스템 캐시를 디스크에 동기화하는 데 사용된다. 버퍼에 저장된 내용을 주기적으로 디스크에 기록한다.(데이터 손실 방지)
        > 두 프로세스는 커널 수준에서만 동작하며, 사용자 공간에서는 보이지 않거나 ps 명령에서 kthread로 나타난다.

    - **PID 1** : init(사용자 공간의 시작점)
        - 사용자 공간에서 최초로 실행되는 프로세스이다.
        - 모든 유저 프로세스들의 부모가된다.
        - Init의 역할
            - 시스템 런레벨 설정
            - 로그인 데몬
            - 서비스 시작
            - 사용자 프로세스 실행
        - 이 이후 실행되는 프로세스들은 init이 생성하는 자식 프로세스들이다.

- **주소 공간 처리 방식**
    - 자식은 다음 중 하나를 따른다.
        - 부모 주소 공간의 완전 복제
        - 부모와 주소 공간을 공유
        - 새 프로그램 로딩(exec 계열 함수)
- **자원 공유 방식**
    - 부모와 자식 간 자원 공유 수준은 OS 정책에 따라 다르다.
        - 모두 공유
        - 일부 공유
        - 전혀 공유하지 않음

## 프로세스 종료(Termination)
- **종료 조건**
    - 정상 종료(exit 호출)
    - 오류 발생 시 비정상 종료
    - 부모가 자식을 강제 종료(kill, abort 등)
- **좀비 프로세스(zombie)**
    - 자식이 종료되었지만, 부모가 wait()로 수거하지 않으면 좀비 상태가 된다.
    - 프로세스 테이블에 일부 정보만 남아 자원 낭비가 발생한다.
- **고아 프로세스(Orphan)**
    - 부모가 먼저 종료되면, 자식은 **init 프로세스**에게 맡겨진다.

## 협력 프로세스(Cooperating Processes)
 - **독립 프로세스** : 다른 프로세스에 영향 없이 실행(자원 미공유)
 - **협력 프로세스** : 데이터를 공유하거나 통신하여 동작을 조율한다.
    - 장점 : 정보 공유, 계산 속도 향상, 모듈화된 설계, 사용자 편의성 증대

## 프로세스 간 통신(IPC: InterProcess Communication)
 목적 : 협력 프로세스 간 데이터 전달과 작업 동기화를 위해 사용한다.

 - **Shared Memory(공유 메모리)**
    - 프로세스 간 공통 메모리 영역을 설정하고 해당 공간에 접근하여 통신
    - 빠르지만 접근 순서/타이밍 관리(동기화) 필요
 - **Message Passing(메시지 전달)**
    - send(), receive() 방식으로 데이터를 직접 전달
    - 서로 다른 주소 공간에서도 동작 가능(분산 시스템에 유리)

 - **Direct 통신** : 송수신 프로세스가 서로의 이름을 알고 직접 메시지를 주고받음
 - **Indirect 통신** : mailbox를 통해 메시지를 주고 받음, mailbox는 여러 프로세스가 공유 가능하며 메시지를 누가 받을지 명확하지 않을 수 있어 동기화 이슈가 발생한다.

## 동기화(Synchronization)
 공유 자원을 동시에 접근하면 데이터 일관성 문제가 발생하여 동기화가 필요하다.

 - **Blocking(동기형)** : send(), receive()가 상대 작업이 완료될 때까지 대기
 - **Non-Blocking(비동기형)** : send() 후 즉시 리턴, receive()는 메시지 없으면 null 리턴

## 버퍼링(Buffering)
 통신 과정에서 메시지는 버퍼(큐)에 저장되며, 다음과 같은 방식이 존재한다.

![Alt text](/assets/OSimages/Buuf.png)

