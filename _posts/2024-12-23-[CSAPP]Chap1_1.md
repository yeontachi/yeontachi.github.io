---
layout: single
title: "[CSAPP Chap1 A Tour of Computer Systems(1)]"
categories: ComputerSystems
---

 시스템 소프트웨어라는 학교 수업을 들으면서 재미를 느껴서 방학동안 "Computer Systems A Programmer's Perspective" - Randal E. Bryant, David R. O'Hallaron 책을 읽으며 그날 공부한 내용을 적어보려합니다. 일단 chapter1은 이 책의 전체 내용을 큰 틀에서만 다루는 느낌이라 요약 정리 느낌으로 적어봤습니다. 

# Chapter 1. A Tour of Computer Systems

이 책은 하드웨어와 시스템 소프트웨어가 함께 작동하여 애플리케이션 프로그램을 실행하는 컴퓨터 시스템의 개념을 이해하고, 이를 통해 프로그래밍 능력을 향상시키려는 개발자를 대상으로 한다.

## 핵심 내용
1. 컴퓨터 시스템의 개념 
- 하드웨어와 소프트웨어의 기본 구성 요소는 시간이 지나도 비슷하며, 동일한 기능을 수행한다.
- 시스템의 작동 원리를 이해하면 프로그램의 정확성과 성능을 향상시킬 수 있다.

2. 배울 수 있는 실용적 기술
- 컴퓨터의 숫자 표현 방식으로 인한 **오류 방지**
- 현대 프로세서와 메모리 시스템을 활용한 **C 코드 최적화**
- **버퍼 오버플로우**로 인한 보안 문제 방지
- **링킹 과정에서 발생하는 오류** 인식 및 해결
- **유닉스 셀, 동적 메모리 할당 패키지, 웹 서버 구현**
- 동시성(Concurrency)의 가능성과 한계 이해

3. "hello" 프로그램을 통한 학습
- C언어의 "hello" 프로그램을 중심으로 컴퓨터 시스템의 모든 주요 부분이 어떻게 협력하여 프로그램을 실행하는지 탐구
- 프로그램 생성, 실행, 종료까지의 **전체 라이프사이클**을 따라가며 주요 개념과 구성 요소를 소개

4. 학습 목표
- 컴퓨터 시스템과 애플리케이션 프로그램 간의 상호작용을 이해하여, **파워 프로그래머**로 성장할 수 있도록 돕는 것이 이 책의 목표

### Chap1-(1)

## 1.1 Information is Bits + Context
```
#include <stdio.h>

int main(){
    printf("hello, world\n");
    return 0;
}
```

### "hello.c" 프로그램의 시작과 저장 방식
- **소스 파일의 생성과 저장**
   - 프로그램은 hello.c라는 텍스트 파일로 저장되며, 프로그래머가 에디터를 사용해 작성한다.
   - 소스 프로그램은 0과 1로 이루어진 비트의 연속이며, 8비트 단위로 묶인 **바이트**로 표현된다.
   - 각 바이트는 프로그램 내 텍스트 문자의 **ASCII 표준** 값으로 저장된다.

- **ASCII와 텍스트 파일**
   - ASCII는 각 문자를 고유한 바이트 크기의 정수 값으로 표현하는 표준
   - 예를 들어, hello.c의 첫 번쨰 바이트 값 35는 문자 "#"을 나타내며, 두 번째 바이트 값 105는 문자 "i"를 나타냄
   - 개행 문자 "\n"은 정수 값 10으로 표현되며, 텍스트 파일은 ASCII 문자로만 구성된 파일을 의미한다.

- **이진 파일과 데이터 표현**
   - 텍스트 파일 외의 모든 파일은 **이진 파일(binary file)**로 분류된다.
   - 시스템의 모든 정보(디스크 파일, 메모리에 저장된 프로그램과 데이터, 네트워크를 통한 데이터)는 **비트의집합**으로 표현된다.

### Context(문맥)에 따른 데이터의 의미
- 동일한 바이트 시퀀스도 **문맥**에 따라 다른 데이터(정수, 실수, 문자열, 기계 명령어 등)로 해석될 수 있음.

### 프로그래머의 이해 필요성
- 컴퓨터의 숫자 표현은 실제 수학적 정수와 실수를 정확히 표현하지 못하는 **finite approximations(유한한 근사치)**로, 예상치 못한 동작을 일으킬 수 있음. (이러한 개념들은 2장에서...)

### 요약 
- 컴퓨터 시스템에서 모든 데이터는 비트로 표현되며, 이를 이해하면 프로그래밍 및 데이터 표현의 작동 방식을 더 잘 이해할 수 있다.

## 1.2 Programs Are Translated by Other Programs into Different Forms

**"hello.c" 프로그램의 변환 과정**
- "hello.c" 프로그램은 사람이 읽을 수 있는 **고급 언어**로 시작되지만, 시스템에서 실행되려면 이를 **저급 기계어 명렁어**로 번역해야 한다. 이 과정에서 **컴파일러 드라이버(ex. gcc)**에 의해 수행되며, **4단계**로 이루어진다.

### 4단계 변환 과정

![Alt text](/assets/images/compilationsystem.png)

linux> gcc -o hello hello.c

**전처리 단계(Preprocessing phase)**
- 전처리기(cpp)가 "#" 문자로 시작하는 명령어를 처리하여 원본 C 프로그램을 수정
- ex. #include <stdio.h>는 stdio.h 헤더 파일의 내용을 프로그램에 삽입
- 결과는 .i 확장자를 가진 새로운 C 프로그램으로 저장됨

**컴파일 단계(Compilation phase)**
- 컴파일러(cc1)가 .i 파일을 **어셈블리 언어 프로그램(.s 확장자)**로 변환
- 어셈블리 언어는 기계어 명령어를 텍스트 형태로 표현하며, 플랫폼에 종속적이지 않은 공통 언어로 사용됨
- ex. main 함수가 기계어 명령어 형태로 정의됨(e.g., movl, call, ret).

```
main:
    subq    $8, %rsp
    movl    $.LCO, %edi
    call    puts
    movl    $0, %eax
    addq    $8, %rsp
    ret
```

**어셈블리 단계(Assembly phase)**
- 어셈블러(as)가 어셈블리 언어 프로그램(.s)을 **기계어 명령어**로 변환
- 결과는 **재배치 가능 오브젝트 프로그램(hello.o)**이라는 바이너리 파일로 저장
- 이 파일은 함수 main의 명령어를 17바이트 크기의 바이너리 형식으로 포함함

**링킹 단계(Linking phase)**
- 링커(ld)가 표준 C 라이브러리의 미리 컴파일된 오브젝트 파일(printf.o)과 hello.o를 병합
- 최종 결과는 **실행 가능한 오브젝트 파일(hello)**로 저장되며, 메모리에 로드되어 실행 가능

### 요약
- **컴파일 시스템** : 전처리기, 컴파일러, 어셈블러, 링커로 구성되며, 고급 언어를 실행 가능한 기계어 프로그램으로 변환
- **기계어 변환** : 소스파일->어셈블리 언어->기계어->실행파일
- 링커는 여러 오브젝트 파일을 병홥하여 완전한 실행 파일 생성

## 1.3 It Pays to Understand How Compilation Systems Work

 단순한 프로그램(hello.c 등)은 컴파일 시스템에 의존해도 정확하고 효율적인 기계어로 변환되지만, **컴파일 시스템의 작동 원리**를 이해하면 아래와 같은 이유로 프로그래밍 역량을 크게 향상시킬 수 있다.

### 1. 프로그램 성능 최적화
- 현대 컴파일러는 고성능의 코드를 생성하지만, 효율적인 코드를 작성하려면 컴파일러가 C 문장을 기계어로 번역하는 방식을 이해해야한다.
- ex. switch 문이 항상 if-else 문보다 효율적인가?
- ex. 함수 호출의 오버헤드는 얼마나 되는가?
- ex. while 루프와 for 루프 중 무엇이 더 효율적인가?
- ex. 배열 인덱스보다 포인터 참조가 더 효율적인가?
- ex. 지역 변수에 합계를 저장하면 전달된 참조 인자보다 왜 더 빠른가?
- (3,5,6장에서 해답 제공 예정)

### 2. 링크 타임 에러 이해
- 대규모 소프트웨어 시스템 개발 시 링커와 관련된 문제는 매우 난해할 수 있다.
- ex. 링커가 "참조를 해결할 수 없다"고 보고하는 의미는 무엇인가?
- ex. static 변수와 전역 변수의 차이는 무엇인가?
- ex. 서로 다른 C 파일에 같은 이름의 전역 변수를 정의하면 어떤 일이 발생하는가?
- ex. 정적 라이브러리와 동적 라이브러리의 차이는 무엇인가?
- ex. 커맨드라인에서 라이브러리 순서가 중요한 이유는 무엇인가?
- ex. 링커 관련 에러가 실행 시간에만 나타나는 이유는 무엇인가?
- (7장에서 질문들에 대한 해답 제공 예정)

### 3. 보안 취약점 방지
- **버퍼 오버플로우 취약점**은 네트워크와 인터넷 서버 보안 문제의 주요 원인이다.
- 이 취약점은 신뢰할 수 없는 데이터 입력을 제한하지 않은 경우 발생한다.
- 데이터와 제어 정보가 **스택(stack)**에 저장되는 방식을 이해하는 것이 보안 프로그래밍의 첫 단계이다.
- 3장에서 스택의 작동 원리와 버퍼 오버플로우 취약점 탐구
- 프로그램, 컴파일러, 운영 체제가 공격 위협을 줄이기 위해 사용하는 방법 학습

### 요약
- 컴파일 시스템의 작동 원리를 이해하면 프로그램 성능 최적화, 링커 오류 해결, 보안 취약점 방지 등 프로그래밍 전반에 걸쳐 더 나은 결정을 내릴 수 있다.

## 1.4 Processors Read and Interpret Instructions Stored in Memory

### 1. "hello" 프로그램의 실행 과정
**1. 실행 파일 호출**

![Alt text](/assets/images/readhello.png) 

- hello.c는 컴파일 시스템을 통해 실행 파일 **hello**로 변환되고 디스크에 저장됨
- **shell**은 사용자가 ./hello 를 입력하면 해당 파일을 실행
- **shell**은 명령을 읽고, 입력이 빌트인 명령이 아니면 실행 파일로 간주해 로드하고 실행

**2. "hello" 실행 과정**
- **1단계**: shell이 디스크에서 hello 실행 파일을 로드하여 메인 메모리에 복사

![Alt text](/assets/images/loadfromdisk.png)

- **2단계**: **DMA(Direct Memory Access)**를 통해 데이터를 디스크에서 메모리로 직접 이동

![Alt text](/assets/images/writetodisplay.png)

- **3단계**: 프로세서가 hello 의 기계어 명령을 실행하여 문자열 "hello, world\n"을 메모리에서 레지스터로 복사하고, 디스플레이 장치로 전달하여 화면에 출력

### 2. 컴퓨터 하드웨어 구성
**버스(Buses)**
- 컴퓨터의 구성 요소 사이에서 데이터를 전송하는 전기적 통로
- **워드 크기(word size)**는 보통 4바이트(32비트) 또는 8바이트(64비트).

**입출력 장치(I/O Devices)**
- 외부 세계와 시스템을 연결
- 키보드, 마우스, 디스플레이, 디스크 드라이브 등이 포함
- 장치는 컨트롤러 또는 어댑터를 통해 I/O 버스에 연결

**메인 메모리(Main Memory)**
- 프로그램과 데이터를 일시적으로 저장
- DRAM 칩으로 구성되며, 논리적으로는 고유 주소를 가진 바이트 배열로 표현
- 변수 크기(ex. short는 2바이트, int와 float는 4바이트, long과 double은 8바이트)는 타입에 따라 다름

**프로세서(CPU)**
- 메인 메모리에 저장된 명령어를 해석하고 실행
- **프로그램 카운터(PC)**가 현재 실행할 명령어를 가리킴
- 명령어 실행:
   - **Load** : 메모리에서 레지스터로 데이터 복사
   - **Store** : 레지스터에서 메모리로 데이터 복사
   - **Operate** : ALU를 사용해 산술/논리 연산 수행
   - **Jump** : 새로운 명렁어 주소를 PC 업데이트
- PC는 personal computer라는 의미도 있지만 여기서는 Program Conuter의 약자이다. Program counter는 메인 메모리의 기계어 명령을 가리키고 있다.

**명령어 세트 구조(ISA)와 마이크로 아키텍쳐**
- ISA: 기계어 명령어의 작동 방식을 정의
- 마이크로 아키텍쳐 : 실제로 프로세서를 구현하는 복잡한 메커니즘.



1.5부터 1.10까지는 다음 장에서...
