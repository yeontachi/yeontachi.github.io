---
layout: single
title: "[CS:APP] Chap3 Machine-Level Representation of Programs(2)"
categories: ComputerSystems
tag: [CS, CSAPP]
toc: true
---

## 3.4 Accessing Information

1. **레지스터 구성**
    - **x86-64 CPU**는 **16개의 일반 목적 레지스터**를 포함하며, 각각 **64비트 값**을 저장한다.
    - 레지스터는 **정수 데이터**와 **포인터**를 저장하는 데 사용된다.
    - 레지스터 이름은 **%r**로 시작한다.
        - 초기 8086 아키텍처 : 8개의 16비트 레지스터(%ax ~ %bp)
        - IA32 확장 : 32비트 레지스터(%eax ~ %ebp)
        - x86-64 확장 : 기존 레지스터를 64비트로 확장(%rax ~ %rbp), 8개의 새로운 레지스터 추가(%r8 ~ %r15)

2. **데이터 크기와 접근**
    - 레지스터는 **바이트 크기(1, 2, 4, 8 바이트)**에 따라 다른 데이터 크기로 작업할 수 있다.
    - 각 데이터 크기에 따라 레지스터의 하위 비트에 접근한다.(1바이트 : 가장 하위 바이트 / 2바이트 : 가장 하위 2바이트 / 4바이트 : 가장 하위 4바이트 / 8바이트 : 전체 레지스터)

3. **상위 비트 처리 규칙**
    - 1바이트, 2바이트 데이터를 생성하는 명령어는 **상위 비트**를 변경하지 않는다.
    - 4바이트 데이터를 생성하는 명령어는 **상위 4바이트를 0으로 설정**한다.

4. **레지스터**
    - **%rsp**(스택 포인터) 
        - 런타임 스택의 끝 위치를 나타낸다.
        - 특정 명령어가 스택 포인터를 읽거나 수정한다.
    - **나머지 15개 레지스터**
        - 더 유연하게 사용 가능하며, 임시 데이터, 함수 인자 전달, 함수 반환값, 로컬 변수 저장에 활용된다.(레지스터마다의 사용 목적이 존재하며, 사용 목적을 반영하여 이름을 지었다.)

    ![Alt text](/assets/images/Figure3.2.png)

5. **프로그래밍 규약**
    - 표준 규칙이 레지스터 사용을 관리
        - 스택 관리
        - 함수 인자 전달
        - 함수 반환값 처리
        - 로컬 및 임시 데이터 저장
    - section 3.7에서 자세히 다룰 예정

### 3.4.1 Operand Specifiers

1. **피연산자와 명령어의 구성**
- 대부분의 명령어는 연산을 수행하기 위한 **소스 값(source values)**과 결과를 저장할 **목적지(destination)**를 지정하는 하나 이상의 피연산자(operands)를 포함한다.

- **x86-64 아키텍쳐**는 다양한 피연산자 형식을 지원하며, 소스 값은 **상수(constants), 레지스터(Registers), 메모리(memory)**에서 가져올 수 있다.

- 결과는 **레지스터**나 **메모리**에 저장할 수 있다.

![Alt text](/assets/images/Figure3_3.png)

2. **피연산자의 3가지 유형**
    - **Immediate(즉시 값)** 
        - **상수 값**을 나타낸다.
        - ATT 형식 어셈블리 코드에서는 **$** 기호로 시작하며, 뒤에 C 표기법을 사용한 정수가 온다.(ex. $0x1f, $577)
        - 명령어마다 사용할 수 있는 즉시 값의 범위가 다르며, 어셈블러는 값에 가장 적합한 인코딩 방식을 자동으로 선택한다.

    - **Register(레지스터)**
        - **레지스터의 내용**을 나타낸다.
        - x86-64에는 16개의 레지스터가 있으며, 각 레지스터는 64, 32, 16, 8비트의 하위 부분을 갖는다.
        - ex. **R[ r<sub>a</sub> ]**는 특정 레지스터 **a**의 값을 나타낸다.

    - **Memory reference(메모리 참조)**
        - **메모리 주소를 계산하여 접근**한다.
        - 메모리는 큰 바이트 배열로 간주되며, 특정 주소의 값을 참조한다.
        - 표기법 : **M<sub>b</sub>[Addr]**는 주소 Addr에서 시작하는 b바이트 값을 나타낸다.

3. **메모리 참조와 주소 계산(Effective Address)**
    - 메모리 참조는 여러가지 주소 지정 방식을 가질 수 있으며, 가장 일반적인 형식은 다음과 같다.
    - **Imm(r<sub>b</sub>, r<sub>i</sub>, s)**
        - **Imm** : 즉시 값(offset)
        - **r<sub>b</sub>** : 기본 레지스터(base register)
        - **r<sub>i</sub>** : 인덱스 레지스터(index register)
        - **s** : 스케일 팩터(scale factor, 1,2,4,8 중 하나)
        - **Effective Address(유효 주소) 계산**
            - **Effective Address = Imm + R[ r<sub>b</sub> ] + R[ r<sub>i</sub> ] x s**
        - 주로 배열과 구조체 요소를 참조할 때 사용한다.

![Alt text](/assets/images/Practice3_1.png)

```
//solution
0x100
0xAB
0x108 // 즉시 값($)
0xFF // %rax에 저장된 값을 메모리 주소로 해석, 메모리 위치 0x100에 위치한 값에 접근
0xAB // Address 0x100 + 4 = 0x104
0x11 // 9 + 0x100 + 0x3 = 0x10C 에 저장되어있는 값에 접근
0x13 // 260 > Hex : 0x104 ... 0x104 + 0x1 + 0x3 = 0x108
0xFF // 0xFC + 0x4 = 0xFF
0x11 //0x100 + 4*0x3 = 0x10C
```

### 3.4.2 Data Movement Instructions

**데이터 이동 명령어**는 데이터를 한 위치에서 다른 위치로 복사하는 데 사용되며, x86-64에서 가장 많이 사용되는 명령어 중 하나이다. 단순한 데이터 이동 명령어로 다양한 작업을 수행할 수 있으며, 명령어는 데이터 크기 (1,2,4,8 바이트)에 따라 **movb, movw, movl, movq**로 구분된다.

![Alt text](/assets/images/Figure3_4.png)

1. **피연산자(Operand) 특징**
    - **Source Operand** : 소스 값은 **즉시 값(immediate), 레지스터(register), 메모리(memory)**에서 가져올 수 있다.
    - **Destination Operand** : 목적지는 **레지스터, 메모리 주소**로 설정 가능하다.
    - **제약 사항**
        - 두 피연산자가 모두 메모리 주소일 수 없다.
        - 메모리 간 데이터를 복사하려면 중간에 **레지스터**를 사용해야한다.

2. **MOV 명령어의 특징**
    - 데이터 크기와 레지스터 크기 일치
        - movb, movw, movl, movq의 데이터 크기와 레지스터 크기가 일치해야한다.
    - 예외
        - **movl** 명령어가 4바이트 값을 레지스터에 저장하면 상위 4바이트를 0으로 초기화
        - x86-64 아키텍쳐에서 채택된 규칙이다.
    - 즉시 값과 메모리 주소 사용
        - **movabsq** 명령어는 64비트 즉시 값을 레지스터에 저장하는데 사용된다.(목적지는 무조건 레지스터)

![Alt text](/assets/images/Acodefordata.png)

3. **작은 소스 크기에서 큰 목적지로 데이터가 이동하는 경우**
    - **MOVZ class**
        - **zero-extension** : 소스 크기보다 큰 목적지 크기를 0으로 채워 확장
    - **MOVS class**
        - **Sign-extension** : 소스 크기보다 큰 목적지 크기를 소스의 **MSB**로 채워 확장
    - 지원 크기 : 1,2바이트 소스를 2,4바이트 목적지로 복사 가능


![Alt text](/assets/images/Figure3_5.png)

![Alt text](/assets/images/Figure3_6.png)

4. **4바이트 -> 8바이트**
    - 4바이트 소스를 8바이트 목적지로 제로 확장하는 명령어는 존재하지 않는다.
    - movl 명령어를 사용해 4바이트 값을 레지스터에 저장하면 상위 4바이트가 자동으로 0으로 설정됨을 이용하여 확장 가능

5. **cltq 명령어**
    - **cltq (Convert Long to Quad)**
        - 소스 : **%eax**
        - 목적지 : **%rax**
        - 부호 확장을 수행하며, **movslq %eax, %rax**와 동일한 동작을 하지만 더 간결한 인코딩을 제공한다.

![Alt text](/assets/images/practice3_3.png)

```
//solution
movb $0xF, (%ebx) 
// %ebs를 주소 레지스터로 사용하면 안된다. 메모리 참조는 64비트 주소 레지스터를 사용해야한다.
movl %rax, (%rsp)
// %r..은 64비트 레지스터이다. movl은 32비트 데이터를 처리함으로 데이터크기와 레지스터 크기가 일치하지 않는다.
movw (%rax),4(%rsp)
// source, Destination 모두 메모리 참조를 할 수 없다.
movb %al,%sl
// 레지스터 sl은 존재하지 않는다.
movq %rax,$0x123
//immdiate value는 destination에 사용할 수 없다.
movl %eax,%rdx
// movld은 32비트 데이터 크기, rdx는 64비트 일치하지 않는다.
movb %si, 8(%rbp)
// 레지스터 %si는 16비트, movb는 8비트 데이터를 처리한다 (일치x)
```

### Data Movement Example

![Alt text](/assets/images/Figure3_7.png)

1. **프로시저의 시작**
    - 함수가 실행되면, 매개변수 xp와 y는 각각 레지스터 **%rdi**와 **%rsi**에 저장된다.
2. **명령어 2 : x = *xp**
    - 메모리에서 x값을 읽어와 레지스터 **%rax**에 저장
    - x = *xp를 어셈블리에서 직접 구현한 것
    - 레지스터 **%rax**는 이후 반환 값으로 사용된다.
3. **명령어 3 : *xp = y**
    - y값을 레지스터 **%rdi**가 지정하는 메모리 주소(xp)에 기록
    - *xp = y 를 구현한 것

- C언어의 **포인터**는 단순히 **메모리 주소**일 뿐이다.
- **포인터 역참조(dereference)**는 포인터를 레지스터에 복사하고, 이 레지스터를 메모리 참조에 사용하는 방식으로 수행된다.
- 로컬 변수는 메모리에 저장되지 않고 주로 레지스터에 저장된다.(레지스터 접근 속도가 메모리 접근보다 훨씬 빠르기 때문이다.)

![Alt text](/assets/images/practice3_5.png)

```c
//solution
void decode1(long *xp, long *yp, long *zp){
    long x = *xp;
    long y = *yp;
    long z = *zp;
    *yp = x;
    *zp = y;
    *xp = z;
}
```

### Pushing and Popping Stack Data

1. **스택 데이터 이동 연산**
    - **push**와 **pop** 명령어는 프로그램 스택에 데이터를 추가하거나 제거하는데 사용된다.
    - **스택(stack)**
        - 데이터가 추가되거나 제거될 수 있는 자료구조
        - **LIFO(Last-In, First-Out)** 규칙에 따라 작동
        - 스택은 배열로 구현될 수 있으며, 배열의 한쪽 끝(스택의 "상단(top)")에서만 데이터가 삽입/삭제된다.

![Alt text](/assets/images/Figure3_9.png)

2. **x86-64에서의 스택**
    - x86-64 아키텍쳐에서는 스택이 **메모리의 특정 영역에 저장**된다.
    - **스택의 특징**
        - **아래 방향**으로 확장
            - 스택의 상단(top)요소가 가장 낮은 주소를 가진다.
            - 관례적으로, 스택 그림은 상단을 아래쪽에 표시된다.
        - **스택 포인터(%rsp)**
            - 스택 최상단 요소의 주소를 저장한다.

3. **pushq 명령어**
    - 데이터를 스택에 **push**한다.
    - pushq %rbp의 동작은 아래 두 명령어와 동일하다.

    ```
    subq $8, %rsp        # 스택 포인터 감소
    movq %rbp, (%rsp)    # %rbp 값을 스택에 저장
    ```

    - **동작 과정**
        1. 스택 포인터(%rsp)를 8만큼 감소
        2. 새로운 스택 최상단 주소에 데이터를 기록

    - **효율성**
        - 위 두 명령어는 총 8바이트가 필요하지만 pushq는 단일 명령어로 인코딩되며 1바이트만 필요하다.

    - Figure 3.9 예시
        - %rsp = 0x108, %rax = 0x123 일 대 pushq %rax 실행
        1. %rsp를 8 감소 -> 0x100
        2. 메모리 주소 0x100에 값 0x123 저장

4. **popq 명령어**
    - 데이터를 스택에 **pop**한다.
    - popq %rax의 동작은 아래 두 명령어와 동일하다.
    
    ```
    movq (%rsp), %rax     # 스택에서 값을 읽어 %rax에 저장
    addq $8, %rsp         # 스택 포인터 증가
    ```

    - **동작 과정**
        1. 스택 최상단 주소에서 값을 읽어 레지스터에 저장
        2. 스택 포인터(%rsp)를 8만큼 증가

    - Figure 3.9 예시
        - pushq 이후에 popq %rdx 실행: 
        1. 메모리 주소 0x100에서 값 0x123을 읽어 %rdx에 저장
        2. %rsp를 8 증가 -> 0x108

    - 스택 값 유지 : 값 0x123은 메모리 주소 0x104에 남아 있지만, 스택의 최상단은 항상 %rsp가 가리키는 주소로 간주된다.

5. **스택의 메모리 접근**
    - 스택은 프로그램 코드 및 데이터와 같은 메모리 공간에 포함되어 있다.
    - 스택의 임의 위치에 접근 가능하다.
        - ex. movq 8(%rsp), %rdx 는 스택의 두 번째 64비트 값을 %rdxㄹ로 복사한다.