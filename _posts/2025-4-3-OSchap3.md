---
layout: single
title: "[OS] 프로세스(2) - Process Scheduling"
categories: OS
tag: [CS, OS]
toc: true
---

## 프로세스 스케줄링
 운영체제가 수행하는 가장 핵심적인 일 중 하나는 **CPU를 누구에게 줄지 결정하는 것**이다. 시스템에는 항상 여러 개의 Ready 상태 프로세스가 있고, CPU는 한 번에 오직 하나의프로세스만 실행할 수 있다.

 그래서 운영체제는 **스케쥴러(Scheduler)**를 통해 어떤 프로세스가 언제 실행할지 결정한다. 이걸 바로 **프로세스 스케줄링(Process Scheduling)**이라고 한다.

 **Ready Queue**는 CPU를 기다리는 프로세스들이 모여 있는 대기열로, 이 Ready Queue에 있는 애들 중 누굴 먼저 실행할지 정하는 게 바로 스케줄러의 역할이다.

## CPU-I/O Burst Cycle
 CPU는 단순히 프로스세만 사용하는 것이 아니다. 대부분의 프로그램은 실행 중에 **CPU 연산**도 하고, **입출력(I/O)**도 한다. 예를 들어 워드 프로세서는 입력도 받고, 화면에 출력도 하고, 저장도 한다.

 - **프로세스의 두 가지 동작**
    - **CPU Burst** : CPU를 사용해서 계산하거나 논리를 처리하는 시간
    - **I/O Burst** : 파일 입출력, 사용자 입력 대기 등 CPU 외 작업을 기다리는 시간

![Alt text](/assets/OSimages/CPUIOBurst.png)

 - **CPU 사용**과 **I/O 대기**가 번갈아 나타나는 형태이다. 이런 구조 덕분에 OS는 CPU를 기다리는 프로세스가 있다면 CPU가 쉬지 않도록 다음 프로세스를 빨리 투입할 수 있다.

![Alt text](/assets/OSimages/CPUburstImeHistogram.png)

## Process Scheduler and Scheduling Criteria
 운영체제에서 **프로세스 스케줄러(Process Scheduler)**는 시스템 자원을 효율적으로 사용하고 사용자에게 빠르고 공정한 응답을 제공하기 위해서 반드시 필요한 구성요소이다. 특히 프로세스 스케줄러는 **CPU 스케줄링**을 담당하며, 이는 곧 **단기 스케줄러(short-term scheduler)**라고도 불린다. 

### 프로세스 스케줄러의 역할
 프로세스 스케줄러는 **준비 상태(ready state)**에 있는 여러 프로세스들 중에서, **CPU 실행을 위해 하나의 프로세스를 선택**하는 일을 담당한다. 이 선택 과정은 **스케줄링 결정(Scheduling Decision)**이라 불리며, 매우 중요한 결정이다. 이때 선택된 프로세스를 실제로 CPU에 할당하는 역할은 **디스 패처(Dispatcher)**가 수행한다.

 스케줄링 결정은 프로세스 상태 전이 중 다음의 세 가지 경우에 발생할 수 있다.
 
 1. **실행 중에서 대기 상태로 전이할 때** 
    - 예: 프로세스가 I/O 작업을 요청하는 경우
 2. **실행 중에서 준비 상태로 전이할 때**
    - 예: 프로세스가 할당된 시간 조각(time slice 또는 quantum)이 만료된 경우
 3. **프로세스가 종료될 때**

### 비선점형 스케줄링 (Non-preemptive Scheduling)
 비선점형 스케줄링에서는 프로세스가 **CPU를 스스로 반납할 때까지 계속 실행**된다. 이는 위에서 언급한 경우 중 (1), (3)에 해당된다. 즉, 프로세스 I/O 요청으로 대기 상태로 전이하거나, 작업을 모두 마치고 종료될 때까지 CPU는 해당 프로세스에 할당된다.

 이 방식은 구현이 단순하고 오버헤드가 적지만, CPU를 오랫동안 사용하는 **CPU 바운드(CPU-bound)** 프로세스가 있으면 **짧은 작업들이 기다리는 시간이 길어지는 문제**가 발생할 수 있다. 이는 대화식 환경이나 실시간 시스템에는 적합하지 않다.

![Alt text](/assets/OSimages/non-preemptive.png)

### 선점형 스테줄링(Preemptive Scheduling)
 선점형 스케줄링은 **현재 실행 중인 프로세스를 강제로 중단하고,** 다른 프로세스에게 CPU를 할당하는 방식을 말한다. 이 방식은 (1), (2), (3) 모두에서 스케줄링이 발생할 수 있으며, 특히 시간 공유 시스템(time-sharing system)에서 많이 사용된다.

 선점형 스케줄링은 **반응 시간(response time)**을 줄이고, 여러 프로세스가 공정하게 CPU를 사용할 수 있도록 한다. 하지만 **문맥 교환(Context Switch)**이 자주 발생하므로 **오버헤드**가 증가할 수 있다.

![Alt text](/assets/OSimages/PreemptiveSche.png)

### 디스패처(Dispatcher)
 디스패처는 스케줄러가 선택한 프로세스를 **실제로 CPU에서 실행되도록 하는 모듈**이다. 디스패처는 다음과 같은 작업을 수행한다. : 
  - **문맥 교환(Context Switch)** : 이전 프로세스의 상태를 저장하고, 새 프로세스의 상태를 불러온다.
  - **프로그램 카운터 설정** : 새 프로세스가 어디서부터 실행을 재개해야 하는지를 결정한다.
  - **사용자 모드로 전환** : 커널 모드에서 사용자 모드로 전환하여 프로그램 실행을 시작한다.

 이러한 작업들에는 **시간 지연(dispatch latency)**이 존재하며, 이는 시스템 응답 속도에 영향을 줄 수 있다.

### CPU 스케줄링 성능 평가 기준
 운영체제는 다양한 CPU 스케줄링 알고리즘을 제공하며, 이를 **정량적으로 비교하기 위해 평가 기준**이 존재한다. 대표적인 기준은 다음과 같다.
  - **CPU 이용률(CPU Utilization)** : CPU가 일을 하고 있는 시간의 비율이다. 이상적인 시스템은 CPU를 항상 바쁘게 유지하려고 한다. 일반적으로 40% ~ 90% 사이의 CPU 이용률을 목표로 한다.
  - **처리율(Throughput)** : 단위 시간당 완료된 프로세스 수이다. 처리율이 높을수록 더 많은 작업이 처리되는 것이다.
  - **반환 시간(Turnaround Time)** : 프로세스가 시스템에 들어와서 완전히 종료되기까지 걸린 총 시간이다. (반환시간 = 종료시간 - 도착 시간)
  - **대기 시간(Waiting Time)** : 프로세스가 레디 큐에서 기다린 시간의 총합이다. CPU를 실제로 사용한 시간이나 I/O 대기시간은 포함되지 않는다. (대기 시간 = 반환 시간 - CPU 실행 시간 - I/O 시간)
  - **응답 시간(Response Time)** : 요청이 제출된 후, 첫 번째 응답이 시작되기까지의 시간이다. 주의할 점은 전체 결과가 나오는 시간(turnaround time)과는 다르며, 대화형 시스템에서 매우 중요한 지표이다.

### 최적화 목표(Optimizaion Criteria)
 운영체제가 추구하는 스케줄링의 이상적인 목표는 다음과 같다: 
  - CPU 이용률을 최대화
  - 처리율을 최대화
  - 반환 시간, 대기 시간, 응답 시간을 최소화

 또한, 단일 값 외에도 평균 지표들도 중요한 기준이 된다.:
  - 평균 CPU 이용률
  - 평균 처리율
  - 평균 반환 시간
  - 평균 대기 시간
  - 평균 응답 시간

 각 스케줄링 알고리즘은 이 기준들에 대해 서로 다른 특성을 가지며, **시스템의 목적에 땨라 적절한 알고리즘을 선택하는 것이 중요하다. 예를 들어, 실시간 시스템에서는 응답시간이 가장 중요하고, 배치 처리 시스템에서는 처리율이 우선시될 수 있다.

## CPU Scheduling Algorithms
 운영체제에서 **CPU 스케줄링(CPU Scheduling)**은 프로세스 관리의 핵심이다. 현대 컴퓨터 시스템은 여러 개의 프로세스가 동시에 실행되기를 원하지만, CPU는 한 번에 하나의 작업만을 처리할 수 있다. 따라서 **준비 상태(Ready state)**에 있는 프로세스들 중에서 **어떤 프로세스를 우선적으로 실행할 것인지**를 결정하는 전략이 필요하며, 이를 위한 알고리즘을 **CPU 스케줄링 알고리즘**이라고 한다.

### 스케줄링 알고리즘이란?
 스케줄링 알고리즘은 **Ready Queue**에 있는 프로세스들 중에서 CPU를 어느 프로세스에 할당할지를 결정하는 전략이다. 스케줄러는 이 알고리즘을 기반으로 다음에 실행할 프로세스를 선택하며, 선택된 프로세스는 디스패처에 의해 CPU에 전달된다.

 대표적인 스케줄링 알고리즘에는 다음과 같은 것들이 있다.
  - FCFS (First-Come, First-Served)
  - SJF (Shortest Job First)
  - Priority Scheduling
  - RR (Round Robin)
  - Multilevel Queue Scheduling
  - Multilevel Feedback-Queue Scheduling

### First-Come, First-Served(FCFS)
 FCFS는 가장 간단한 스케줄링 알고리즘으로, **CPU 요청이 먼저 들어온 순서대로 처리**한다. 선입선출(FIFO) 방식으로 구현되며, **비선점형(Non-preemtive) 스케줄링에 속한다.

 - **구현** : FCFS는 레디 큐를 **선입 선출 큐(FIFO queue)**로 구현한다. 프로세스는 도착한 순서대로 큐에 들어가고, CPU는 큐의 앞에 있는 프로세스부터 순차적으로 할당된다.

 ![Alt text](/assets/OSimages/FCFSalgorithm.png)

 - **예제** 

 ![Alt text](/assets/OSimages/FCFSGantt.png)

 - **도착 순서** : P1, P2, P3
 - **대기 시간** : P1 = 0; P2 = 24; P3 = 27
 - **평균 대기 시간** : ( 0 + 24 + 27 ) / 3 = 17

 ![Alt text](/assets/OSimages/FCFSGantt2.png)

 - **대기 시간** : P1 = 6, P2 = 0; P3 = 3
 - **평균 대기 시간** : ( 6 + 0 + 3 ) / 3 = 3
 - 도착 순서를 바구면 평균 대기 시간은 3ms로 현저히 줄어드는 것을 확인할 수 있다. -> **문제점** : 긴 작업이 먼저 오면 전체 대기 시간이 길어지는 Convot Effect(호송 효과)가 발생한다.

### Shortest Job First (SJF)
 SJF는 **CPU 버스트 시간**이 가장 짧은 프로세스를 우선 실행한다. 평균 대기 시간을 최소화할 수 있으며, 이론적으로 **가장 효율적인(non-preemptive) 알고리즘**이다.

 - **방식**
    - **비선점형 SJF** : 현재 실행 중인 프로세스가 끝나기 전까지 다른 프로세스가 도착해도 CPU를 양보하지 않는다.
    - **선점형 SJF** : 실행 중인 프로세스보다 더 짧은 CPU 버스트를 가진 프로세스가 도착하면 CPU를 양보한다.

 - **예제** 

 ![Alt text](/assets/OSimages/SJFGantt.png)

 - **대기 시간** 
    - P1 = 0 msec
    - P2 = (8 - 1) ms
    - P3 = (17 - 2) ms
    - P4 = (12 - 3) ms
 - **평균 대기 시간** : ( 0 + 7 + 15 + 9 ) / 4 = 10.25ms
 - 미래 CPU 버트스 시간을 **정확히 예측하기가 어렵다** 또한 **짧은 작업 위주로 실행**되면 긴 작업이 무기한 대기하는 **Starvation** 문제 발생

### Priority Scheduling
 각 프로세스에 **우선 순위(priority)**를 부여하여, 우선 순위가 가장 높은 프로세스를 먼저 실행한다.(보통 작은 숫자가 높은 우선순위)

 - **방식**
    - **비선점형** : 현재 실행 중인 프로세스는 우선순위가 낮더라도 끝날 때까지 실행

    ![Alt text](/assets/OSimages/PreemprivePriority.png)

    - **선점형** : 우선순위가 더 높은 새 프로세스가 오면 현재 프로세스를 중단

    ![Alt text](/assets/OSimages/NonPreemtivePriority.png)

 - **예제** 

![Alt text](/assets/OSimages/priorityScheduling.png)

 - **대기 시간**
    - P1 = 6
    - P2 = 0
    - P3 = 16
    - P4 = 18
    - P5 = 1
 - **평균 대기 시간** : ( 6 + 0 + 16 + 18 + 1) / 5 = 8.2ms
 - 낮은 우선순위 프로세스는 실행 기회를 잃는 **Starvation** 문제가 발생할 수 있다. -> 해결책 : Aging 기법(대기 시간이 길어질수록 우선 순위를 점진적으로 올림)

### Round Robin(RR)
 **Round Robin(RR)**스케줄링은 **시분할 시스템(time-sharing system)**을 위해 설계된 스케줄링 방식이다. 모든 프로세스가 **동등한 기회를 갖도록, 고정된 시간 단위(time quantum)** 동안만 CPU를 사용하게 하고, 그 시간이 끝나면 큐의 뒤로 이동한다.
  - FCFS 방식에 preempion 기능을 추가한 형태
  - 사용자 응답 시간을 줄이고, 시스템의 반응성을 높이기 위해 설계되었다.

 - **스케줄링 방식**
    - 모든 프로세스는 **동일한 우선순위**를 가진다.
    - CPU를 사용할 수 있는 시간은 정해진 시간 조각인 **Time Quantum(또는 Time Slice)**으로 제한된다.
    - 각 프로세스는 자신의 Time Quantum이 끝나면 **강제로 CPU에서 내리고**, 다시 준비 큐의 뒤로 이동한다.
    - 그 다음 프로세스가 FIFO 순서대로 CPU를 할당 받는다.(Time Quantum은 10~100ms)

![Alt text](/assets/OSimages/RR.png)

 - **예제** 
    
![Alt text](/assets/OSimages/RRGantt.png)

 - **대기 시간**
    - P1 : 53 -> 20 + 20 + 13
    - P2 : 17 
    - P3 : 68 -> 20 + 20 + 20 + 8
    - P4 : 24 -> 20 + 4
 - **평균 대기 시간** : (53 + 17 + 68 + 24) / 4 = 40.5
 - **RR**은 일반적으로 **SJF보다 평균 반환 시간(Turnaround Time)**은 높지만, **응답 시간(Response Time)**은 더 우수하다. 즉, 사용자 체감 반응 속도가 빠르다.

 - **RR의 수학적 특성 및 분석** : 준비 큐에 n개의 프로세스가 있고, Time Quantum을 q라고 할 때, 각 프로세스는 최대 q 단위씩, 1/n 비율로 CPU를 나눠 가진다. 또한 어떤 프로세스도 (n-1) x q 이상 기다리지 않는다. 단, CPU burst가 q보다 작으면, 해당 프로세스는 그 시간 내에 완료된다.

 - **Time Quantum의 영향**

  ![Alt text](/assets/OSimages/EffectTimeQuantum.png)

  - **Time Quantum이 너무 큰 경우** : 거의 FCFS처럼 동작하며(선점의 의미가 없어짐), 응답 시간이 길어진다(시분할 시스템에 부적합)
  - **Time Quantum이 너무 작은 경우** : 문맥 교환(Context Switch)이 빈번하게 발생하여 **시스템 오버헤드가 증가**한다. CPU의 실질적인 사용 시간이 줄어들게 되면서 성능 저하를 유발한다.
  - **적절한 Quantum** : 문맥 교환 오버헤드보다 충분히 크면서, 응답성을 확보해야 한다. 현대 OS에서는 일반적으로 10 ~ 100ms 정도로 설정한다. (문맥 교환 오버헤드는 보통 10μs 미만)

### Multilevel Queue Scheduling
 **Multilevel Queue Scheduling**은 하나의 레디 큐(Ready Queue)를 사용하는 대신, **여러 개의 독립된 큐**를 만들어 프로세스를 **특성별로 분리**하여 관리하는 방식이다. 시스템은 각 프로세스가 가진 고유한 특성(예: 우선 순위, 입출력 빈도, 메모리 사용량 등)에 따라 해당 프로세스를 하나의 큐에 **고정적으로 할당**한다.

 - **스케줄링 방식**
    - 레디 큐를 여러 개로 나눈다.(예: Foreground Queue, Background Queue, Read-time Queue 등)
    - 프로세스는 시스템 초기화 또는 생성 시점에 하나의 큐에 고정된다.
    - 각 큐는 서로 다른 스케줄링 알고리즘을 사용할 수 있다.

 - **큐 간 스케줄링** : 프로세스는 하나의 큐 안에서만 스케줄링되지만, 여러 큐 중 어느 큐의 프로세스를 우선 실행할지는 **고정 우선순위(Fixed Priority)** 또는 **시간 분할(Time Slice)** 방식으로 결정된다.

   - **고정 우선순위 방식**
    - 가장 높은 우선순위 큐에 있는 프로세스들만 먼저 실행된다.
    - 낮은 큐는 높은 큐가 비워질 때까지 기다려야 한다.
    - Starvation 현상 발생 가능

   - **시간 분할 방식(Time Slice)**
    - CPU 시간을 큐들 사이에 일정 비율로 배분한다.
    - 각 큐는 자신에게 할당된 시간 동안 내부 프로세스들을 처리한다. 

 - **예제** : 우선순위 기반 멀티레벨 큐
    - 큐는 우선 순위 0(가장 높음)부터 6(가장 낮음)까지 구성되어 있다.
    - 각 큐에는 다음과 같이 프로세스가 분배된다.

    ![Alt text](/assets/OSimages/MQSPriority.png)

    - 스케줄러는 항상 가장 높은 우선순위 큐부터 탐색하여 실행할 프로세스를 선택한다.
    - starvation 발생

### Multilevel Feedback-Queue Scheduling
 Multilevel Queue scheduling의 가장 큰 단점은 **프로세스가 처음 배정된 큐에서 이동할 수 없다는 점**이다. 이로 인해 다음과 같은 문제가 발생한다.
  - **입출력 중심(I/O-bound)** : 프로세스가 낮은 우선 순위 큐에 고정되면, 응답 시간이 길어진다.
  - **CPU 사용량이 높은 프로세스**가 높은 우선 순위 큐에 있으면, 다른 프로세스들이 오랫동안 대기한다.
 이 문제들을 해결하기 위해 Multilevel Feedback-Queue Scheduling이 도입되었다.
 
 Multilevel Feedback Queue는 다음과 같은 특징을 가진다.
  - 프로세스가 여러 큐 사이를 이동할 수 있다.
  - **프로세스의 실행 특성(예: CPU burst 시간)**에 따라 우선 순위를 동적으로 조정한다.
  - I/O-bound 프로세스는 우선순위를 올려 빠르게 응답, CPU-bound 프로세스는 낮은 큐로 내려 보냄으로써 공정성과 효율성을 동시에 달성한다.

 - **동작 원리**
    - 모든 프로세스는 가장 높은 우선순위 큐에서 시작
    - 주어진 시간(q)를 초과하면 낮은 우선순위 큐로 이동
    - 빠르게 끝나는 프로세스는 높은 우선순위 큐에 머물게 되어, 빠른 응답을 확보

![Alt text](/assets/OSimages/MQSFeedback.png)

 - **장점**
    - 동적 우선 순위 조정으로 CPU와 I/O 사용 균형 유지
    - 다양한 유형의 작업에 대해 높은 유연성과 효율성 제공
    - starvation 방지, 반응성 향상, 공정성 향상

 - **단점**
    - 알고리즘 복잡도 높고 구현이 어려움
    - 우선 순위 조정 정책이 적절하지 않으면 성능 저하 가능성
    - 각 큐의 time quantum, 이동 조건 등을 세심히 설계해야 함

### Windows XP Scheduling
Windows XP는 고성능과 반응성을 동시에 만족시키기 위해, **우선순위 기반(priority-based)**이면서 **선점형(preemptive)**인 다단계 피드백 큐(Multilevel Feedback Queue) 스케줄링 방식을 채택하였다.

이 방식은 대화형(interactive) 프로그램과 CPU 사용량이 많은 프로그램 사이에서 공정한 CPU 분배를 보장하면서도, 사용자 경험이 중요한 프로세스의 응답 속도를 높이기 위해 설계되었다.

- **우선 순위 클래스 구조** : Windows XP의 스케줄링은 **두 가지 우선순위 클래스(priority class)**를 기반으로 한다

    - **실시간 클래스 (Real-Time Class)**
        - 우선순위 16 ~ 31
        - 가장 높은 우선순위를 가지며, 운영체제가 직접 사용하는 중요한 작업이나, 실시간 응답이 요구되는 프로세스가 포함된다.
        - 예: 하드웨어 컨트롤, 시스템 드라이버 등

    - **가변 클래스 (Variable Class)**
        - 우선순위 1 ~ 15
        - 대부분의 사용자 애플리케이션이 여기에 포함된다.
        - 이 클래스의 우선순위는 동적으로 조정될 수 있다.
 > 우선순위 0은 사용되지 않는다.

- **스케줄링 동작 방식**
    - Window XP는 우선순위가 높은 프로세스를 항상 먼저 실행하며, 동일한 우선 순위를 가진 프로세스들끼리는 Round Robin 방식으로 순환 실행된다.
    - 스케줄러는 모든 큐를 높은 우선순위부터 순차적으로 검사하여, 실행 가능한 프로세스를 선택한다.

- **동적 우선수위 조정**
    - Window XP의 중요한 특징은 **변동 우선순위(variable priority)**를 사용하여 **CPU 사용량이 높은 프로세스를 억제하고, 대화형 프로세스의 반응성을 개선하는 데 있다.
    - **동작 원리** : 
        - **CPU-bound** : 지속적으로 CPU만 사용하는 경우 우선 순위 하락
        - **I/O-bound** : 사용자 입력 등으로 자주 대기 상태가 되면 우선 순위 상승

    - 이러한 방식은 **인터랙티브(interactive)**한 작업이 높은 우선순위를 유지하도록 하여, 사용자의 체감 반응 속도를 향상시킨다.
    - 동시에 **배치(Batch Process)**은 우선순위가 낮아져 CPU 독점 장비 효과도 있다.

![Alt text](/assets/OSimages/WindowsXP.png)

### Linux Scheduling
 리눅스 운영체제 역시 **우선 순위 기반(Priority-Based), 선점형(Preemptive), 다단계 피드백 큐(Multilevel Feedback Queue)** 스케줄링 방식을 채택하고 있다. 하지만 Linux는 오픈소스 커널답게 지속적인 발전을 거듭해 왔으며, 버전에 따라 스케줄러의 구조와 성능이 크게 향상되었다.

 특히, Linux2.5 버전 이후부터는 새로운 알고리즘 도입을 통해 스레드 수에 관계없이 일정한 시간 안에 스케줄링이 가능하도록 개선되었다.

 - **스케줄링 전략 요약**
    - **선점형 스케줄링** : 높은 우선 순위의 테스크가 도착하면 현재 테스크를 중단
    - **다단계 피드백 큐 기반** : CPU 사용 패턴에 따라 우선 순위 조정
    - **우선 순위 기반** : 높은 우선순위 프로세스부터 실행
    - **O(1) 스케줄링**(linux 2.6 이전) : 고정 시간 내에 스케줄링 결정 가능
    - **CFS(Completely Fair Scheduler)**(Linux 2.6.23 이후) : 공정한 분배 기반의 스케줄러로 전환

![Alt text](/assets/OSimages/Linux.png)

 - **리눅스 우선순위 체계** : Linux에서는 모든 프로세스에 대해 고정된 숫자의 우선순위가 부여되며, 이는 두 가지 범주로 나뉜다.
    - **실시간 우선 순위(Real-time Priority)**  
        - 우선 순위 범위 : 0 ~ 99
        - 가장 높은 우선 순위 -> 시스템의 핵심적인 실시간 작업에 사용
        - 스케줄링 정책 : SCHED_FIFO, SCHED_RR 등
    - **일반 프로세스 우선순위(Nice value 기반)**
        - 우선 순위 범위 : 100 ~ 140
        - 사용자 태스크나 백그라운드 작어베 해당
        - 낮은 nice 값일수록 높은 우선 순위를 의미함

    > nice 값은 명령어를 통해 조정 가능하며, 이를 통해 시스템 자원 배분을 유도 가능

 - **Runqueue 구조** : Linux는 각 CPU마다 Runqueue라는 자료구조를 사용하여 실행 가능한 태스크들을 관리한다. Runqueue는 다음과 같이 두 개의 배열로 구성된다.
    - **Active array** : 현재 CPU에서 실행할 수 있는 태스크
    - **Expired array** : 자신의 Time Quantum을 다 써서 한동안 대기해야 하는 태스크

    - **동작 방식**
        - 프로세스는 Active array에서 실행되다가, Quantum이 만료되면 Expired array로 이동한다.
        - 모든 프로세스가 Expired로 이동한 시점에, 두 배열의 역할을 교체한다.
        - 이를 통해 CPU가 특정 태스크에 편중되지 않도록 보장하며, **공정성(Fairness)**를 유지한다.

 - **동적 우선순위 조정** : Linux는 프로세스의 행동패턴에 따라 우선순위를 동적으로 조정하여 다음과 같은 특성을 구현한다.
    - **I/O-Bound** : 더 높은 동적 우선순위 부여 -> 빠른 응답
    - **CPU-Bound** : 낮은 동적 우선순위 부여 -> CPU 점유 억제

    - 결과적으로 대화형 프로세스의 반응 속도는 향샹되고, CPU 점유가 많은 작업은 배경에서 조용히 처리된다.
    - 사용자 경험을 개선하면서, 자원도 효율적으로 배분하는 효과를 갖는다.

 - **O(1) 스케줄링과 오버헤드 개선** : 기존 전통적인 스케줄링 방식에서는 스레드 수에 비례해서 스케줄링 결정 시간이 늘어났다. 하지만 Linux 2.5 이후 도입된 O(1) 스케줄러는 이러한 문제를 해결했다.
    - **시간 복잡도** : 스레드 수 관계없이 O(1) 시간 내에 스케줄 결정 가능
    - **CPU 코어별 스케줄링** : 각 CPU마다 독립적인 Runqueue 운영
    - **컨텍스트 스위치 비용 최소화** : 문맥 전환 최소화 -> 시스템 반응성 향상

 > 이후 Linux 2.6.23부터는 **CFS (Completely Fair Scheduler)**가 도입되어, 프로세스에 정확히 공정한 CPU 시간을 분배하도록 개선됨

Linux는 성능과 공정성을 동시에 만족시키기 위해 설계된 스케줄러를 가지고 있다. 특히 O(1) 알고리즘은 스레드 수가 많아도 스케줄링 결정 시간이 일정하게 유지되어, 멀티코어 시스템에서 매우 높은 효율을 보인다. 또한 동적 우선순위 조정 메커니즘은 사용자 중심의 빠른 반응성과 자원 관리 효율을 함께 제공한다.

이후 버전에서 등장한 CFS는 이런 기조를 유지하면서도 실제 시간을 기반으로 공정한 분배를 실현하고 있으며, 현대 리눅스 배포판(예: Ubuntu, Fedora 등)의 핵심 스케줄러로 사용된다.