---
layout: single
title: "[OS] Secondary Storage Structure(Disk, 디스크)"
categories: OS
tag: [CS, OS]
toc: true
---

 운영체제는 사용자와 하드웨어(디스크) 사이의 중재자 역할을 하며, 디스크의 물리적 세부사항을 추상화하여 파일 시스템이나 메모리 관리 기능을 구현한다. 디스크 구조를 이해하는 것은 I/O 성능이나 디스크 스케줄링, 스왑 공간 같은 주요 기능을 이해하는 데 필수이다.

## Disk Structure(디스크 구조)

![Alt text](/assets/OSimages/Diskimg.png)

### 디스크 접근 시간(Disk Access Time)
 운영체제가 디스크에서 데이터를 읽을 때 걸리는 시간은 다음과 같이 계산된다.
  - **디스크 접근 시간 = 포지셔닝 시간 + 전송 시간**
  - **포지셔닝 시간** : 디스크 헤드를 원하는 위치로 이동시키는 시간
    - **탐색 시간(Seek Time)** : 헤드를 해당 실린더로 이동
    - **회전 지연(Roatational Latency)** : 원하는 섹터가 헤드 아래로 올 때까지 대기
  - **전송 시간** : 디스크에서 메모리로 데이터를 보내는 시간

 > 운영체제는 이 값을 최소화하기 위해 디스크 스케줄링 알고리즘을 사용한다.

### 디스크의 추상화 : 섹터(Sector)와 블록(Block)
 운영체제는 하드웨어의 복잡한 구조를 다음과 같이 단순화해서 사용한다. : 
  - 디스크는 OS 입장에서 **1차원 배열처럼 보인다.**
  - 실제로는 각 섹터는 **[실린더 번호, 트랙 번호, 섹터 번호]**로 매핑된다.
  - OS는 이러한 물리 주소를 거의 직접 다루지 않고, **논리 블록 번호(LBA)** 기준으로 관리한다.
  - **블록** 또는 **섹터**는 운영체제가 디스크에 접근할 때 사용하는 **최소 단위**이다.

![Alt text](/assets/OSimages/DisckSectorBlock.png)

### 디스크 컨트롤러(Disk Controlloer)
 운영체제는 직접 디스크에 접근하지 않고, 대신 **디스크 컨트롤러**를 통해 요청을 전달한다.
   - 컨트롤러는 OS의 명령을 받아 하드웨어에 전달한다.
   - I/O 요청 큐를 관리하며, 어느 요청을 먼저 처리할지 정한다.
   - 캐시(Buffer) 기능도 포함 -> 같은 요청 반복 시 빠르게 응답이 가능하다.

 > 운영체제는 디바이스 드라이버를 통해 컨트롤러와 통신한다.

### 디스크 회전 방식과 데이터 배치

![Alt text](/assets/OSimages/disktypeimg.jpeg)

- **CLV(Constant Linear Velocity)** : 트랙이 바깥쪽으로 갈수록 길어진다. -> 더 많은 데이터를 저장함. 디스크 회전 속도를 계속 조절해야한다. (예: CD-ROM, DVD-ROM)
    - 바깥쪽 트랙은 길이가 길지만 **데이터 밀도는 일정**하게 유지된다.
    - 회전 속도를 **조절**하여 일정한 전속 속도를 유지한다.
    - 운영체제가 이를 직접 제어하진 않지만, 일정한 읽기 속도를 기대할 수 있다.

- **CAV(Constant Angular Velocity)** : 디스크는 일정 속도로 회전하지만, 바깥쪽 트랙일수록 더 많은 섹터를 저장할 수 있다. OS는 이런 구조를 활용해서 성능 최적화가 가능하다.(예: HDD, 플로피디스크)
    - 회전 속도는 일정하지만, 바깥쪽 트랙은 더 많은 데이터를 담을 수 있다.
    - OS는 바깥쪽 트랙을 **우선적으로 사용**해서 성능을 높이기도 한다.

- **디스크 용량 늘리는 방법(벤터 관점)** : 운영체제는 디스크의 용량이나 속도를 직접 개선하지 않지만, 디스크의 구조가 바뀌면 OS도 그에 맞게 대응해야 한다. 
    - **섹터 수 증가** : 한 트랙당 섹터 수를 늘리면 더 많은 데이터를 저장 가능하다.
    - **실린더 수 증가** : 트랙 수 자체를 늘림으로써 용량을 증가시킨다.

 > 운영체제는 이런 구조를 추상화해서 논리 블록 번호(LBA) 기반으로 접근한다. 즉, "섹터 100번"이 어디 있는지 OS가 몰라도된다. 컨트롤러와 하드웨어가 알아서 처리한다.

## Disk Scheduling(디스크 스케줄링)
 운영체제에서 디스크는 속도가 느린 자원이다. 특히 디스크에 접근하는 요청이 많을수록 성능 병목(bottleneck)이 생길 수 있다. 예를 들어, 여러 프로세스가 동시에 파일을 읽거나 쓸 때, 디스크는 순차적으로 처리할 수밖에 없다. 디스크는 기계적인 움직임이 필요한 장치이기 때문에, 요청 처리 순서가 전체 성능에 큰 영향을 준다. 운영체제는 요청 큐(request queue)를 정렬하여 최적의 순서로 처리한다. 

 ![Alt text](/assets/OSimages/DiskIOflow.png)

 **디스크 I/O 요청 처리 흐름** : 프로세스 → 시스템 콜(read/write) → 파일 시스템 → 버퍼 캐시 → 디스크 드라이버 → 요청 큐 → 디스크
 - 각 요청은 특정 블록(예: B0, B2 등)을 읽거나 쓰기 위한 것
 - 운영체제는 이 요청들을 디스크 요청 큐에 쌓아두고, **스케줄링 알고리즘**을 통해 처리 순서를 결정한다.

 - **디스크 접근 시간 최적화 기준**
    - **Seek Time** : 디스크 암을 원하는 실린더로 이동하는 시간(기계적 움직임으로 가장 느리다.)
    - **Rotational Time** : 섹터가 디스크 헤드 아래로 올 때까지 기다리는 시간(회전 지연)

 - **주요 스케줄링 알고리즘**

 ![Alt text](/assets/OSimages/DiskScheduling.png)

 > 운영체제는 디스크의 사용 목적(파일 서버, DB 서버, 일상용 등)에 따라 가장 적합한 알고리즘을 선택해 사용한다.

### First Come, First Service(FCFS)

![Alt text](/assets/OSimages/FCFS.png)

 - 요청 순서대로 처리를 한다.
 - 성능은 최악(비효율적인 이동이 발생한다. 예: 183 -> 37)

### Shortest-Seek-Time-First(SSTF)

![Alt text](/assets/OSimages/SSTF.png)

 - 현재 디스크 헤드의 위치에서 가장 가까운 요청부터 처리하는 알고리즘
 - 디스크 헤드가 위치한 지점에서 **가장 이동 거리가 짧은 요청**을 선택한다.
 - 일종의 **탐욕적(greedy)** 알고리즘
 - 평균 Seek Time이 짧고 빠른 응답시간으로 SSTF는 **단일 사용자 환경이나 가벼운 워크로드**에서 많이 사용된다.
 - **단점 : Starvation 문제 발생** : 요청 큐에 183번 요청이 존재하는 경우 183번보다 현재 디스크 헤드의 위치에서 가까운 요청이 들어오면, 디스크 헤더가 183번으로 영원히 가지 않는 상황이 발생된다.

### SCAN

![Alt text](/assets/OSimages/SCAN.png)

 - 디스크 암(헤드)은 한 방향으로 쭉 이동하면서, 그 방향에 있는 요청들을 순차적으로 처리하고, 끝에 도달하면 방향을 바꿔 반대 방향으로 또 요청들을 처리하는 방식이다.(엘리베이터 방식으로도 불림)
 - Starvation 문제가 발생하지 않는다.
 - 연속적인 요청에 강하다.(데이터가 순차적으로 저장될 때 효과적이다.)

### C-SCAN

![Alt text](/assets/OSimages/CSCAN.png)

 - 디스크 헤드는 한 방향으로 요청을 처리하고, 끝에 도달하면 처음으로 되돌아가되, 돌아가는 길에는 아무 요청도 처리하지 않는다.
 - 처리 방향은 단방향이고, 돌아가는 과정은 리셋 느낌이고 요청을 무시한다.

### LOOK and C-LOOK
 LOOK과 C-LOOK은 SCAN/C-SCAN의 "불필요한 끝까지의 이동"을 제거한 버전이다.
 - **LOOK**은 SCAN처럼 양방향 처리를 하지만, 실제로 요청이 있는 마지막 트랙까지만 가고, 거기서 방향을 바꾼다. 
 - **C-LOOK**은 C-SCAN처럼 단방향으로만 처리하지만, 처리 가능한 가장 먼 요청까지만 이동하고, 다시 맨 처음 요청이 있는 곳으로 점프한다.(그 사이 요청들은 모두 무시)

## Disk Formatting(디스크 포맷팅)

### Low-Level Formatting(물리적 포맷)
 디스크를 섹터 단위로 나누는 작업, 하드웨어 수준에서 수행된다.

 - 디스크가 데이터를 저장할 준비를 하는 가장 기초적인 단계이다.
 - 각 섹터에 다음과 같은 구조가 만들어진다.

![Alt text](/assets/OSimages/DiskSectorAr.png)

 - Header/ Trailer는 디스크 컨트롤러가 사용하는 정보를 포함한다. : 
    - 섹터 번호
    - 오류 정정 코드(ECC)
 - 이 과정은 보통 제조 단계 또는 펌웨어 수준에서만 수행되고, 사용자가 직접 실행하는 경우는 거의 없다.

### Partition + Logical Formatting(운영체제의 포맷)
 운영체제는 디스크를 실제로 사용하기 위해 아래 두 단계가 더 필요하다.

 - **Partitioning(파티셔닝)**
  - 디스크를 여러 개의 논리 구간(파티션)으로 나눈다.
  - 각 파티션은 독립된 디스크처럼 사용 가능하다. (예: C:드라이브, D:드라이브)
 - **Logical Formatting(논리 포맷)**
  - 각 파티션에 파일 시스템 구조를 설치 (에: superblock, inode table, free space bitmap 등)
  > 이 작업을 통해 디스크는 파일을 읽고 쓰는 논리적 단위로 사용 가능해진다.

### 전체 포맷의 정의(Full File System Formatting)
 - **Low-level formatting + logical formatting(+Partition)**

 > 운영체제는 포맷된 디스크에만 파일 시스템을 설치할 수 있고, 이를 통해 파일 단위로 읽기/쓰기 연산을 수행할 수 있다.

## Disk Cache(디스크 캐시)
 디스크 캐시는 디스크의 일부 데이터를 임시로 저장하는 고속 메모리 공간이다. 보통 DRAM이나 SSD 내장 메모리에 위치하며, 디스크 컨트롤러나 OS가 관리한다.
  - **목적** : 느린 디스크 접근을 줄이고, 자주 사용하는 데이터에 빠르게 접근하기 위함이다.
  - **구성** : 디스크에 있는 일부 섹터(블록)를 복사해서 담아두는 버퍼 영역이다.

 - **디스크 캐시 운영**
  - **읽기 요청(Read)**
    - OS가 특정 섹터를 요청
    - 디스크 캐시에 해당 섹터가 있는지 확인(-> 캐시 히트 여부)
        - 있으면 : 디스크 접근 없이 바로 반환
        - 없으면 : 디스크에서 읽어와 캐시에 저장한 뒤, 상위 계층에 반환

  - **쓰기 요청(Write)**
    - OS가 디스크의 특정 섹터를 수정하고자 할 때
        - 있으면 : 해당 블록 업데이트
        - 없으면 : 디스크에서 읽어와 캐시에 저장한 뒤, 상위 계층에 반환
    
    - 쓰기 후 디스크에 즉시 반영할지 or 나중에 반영할지는 정책에 따라 다르다.
        - Write-through : 캐시와 디스크에 동시에 반영(안정성 좋음)
        - Write-back : 일단 캐시에만 반영하고, 나중에 디스크에 씀(속도 빠름)

 > 디스크 캐시는 운영체제가 디스크 접근 속도를 줄이기 위해 사용하는 고속 임시 저장소이다.

