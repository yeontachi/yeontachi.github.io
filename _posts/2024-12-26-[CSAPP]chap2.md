---
layout: single
title: "[CS:APP] Chap2 A Representing and Manipulating Information"
categories: ComputerSystems
tag: [CS, CSAPP]
---

현대 컴퓨터는 0과 1로 표현된 이진 신호를 이용해 정보를 저장하고 처리한다. 일반적으로 사람들에게는 10진법이 더 친숙할 수 있으나, 컴퓨터 설계에서는 이진법이 더 효율적으로 작동한다. 이진법은 유한 집합의 원소를 표현할 수 있으며, 숫자를 표현하는 방식에는 세 가지 중요한 방법이 있다. 첫 번째는 Unsigned Encodings으로, 0 이상의 숫자를 표현한다. 두 번째는 Two's Complement Encodings으로, 음수와 양수 모두를 표현할 수 있다. 세 번째는 Floating-Point Encodings으로, 실수를 표현하는 데 사용된다.

컴퓨터는 제한된 비트 수로 숫자를 인코딩하며, 이는 오버플로우를 방지하기 위한 것이다. 예를 들어, 32비트 int 자료형을 사용하는 컴퓨터에서 200 * 300 * 400 * 500을 계산하면 -884,901,888이라는 값이 도출된다. 해당 계산에서는 교환 법칙과 결합 법칙이 성립하지만, 양수의 곱 결과가 음수로 나타나는 등 예상과 다른 결과가 나타날 수 있다. 그러나 컴퓨터가 생성한 결과는 일관성을 가지고 있다.

부동소수점 연산은 정수 연산과는 전혀 다른 수학적 특성을 가진다. 양수의 곱은 항상 양수를 반환하지만, 오버플로우가 발생하면 +무한대(∞)를 반환한다. 또한, 부동소수점 연산은 유한 정밀성(finite precision) 때문에 결합 법칙이 성립하지 않는다. 예를 들어, (3.14 + 1e20) - 1e20은 0.0을 반환하지만, 3.14 + (1e20 - 1e20)은 3.14를 반환한다. 이처럼 정수와 부동소수점 연산은 서로 다른 수학적 속성을 가지며, 유한성을 다루는 방식에 따라 차이를 보인다. 정수 연산은 비교적 작은 범위의 값을 인코딩하지만 정확한 값을 반환하며, 부동소수점 연산은 넓은 범위의 값을 인코딩할 수 있지만 대략적인 값을 반환한다.

컴퓨터는 숫자 값을 인코딩하기 위해 다양한 이진 표현 방식을 사용하며, 이는 값의 범위와 산술 연산의 특성을 이해하는 데 매우 중요하다. 이러한 이해는 이식성 있는 프로그램을 작성하고 보안 취약점을 방지하는 데 필요한 기초가 된다. 컴퓨터 산술의 미묘한 특성으로 인해 보안 취약점이 발생할 수 있으며, 해커들은 이러한 취약점을 악용하려고 한다. 따라서 프로그래머는 프로그램이 예상치 못한 방식으로 작동하지 않도록 깊이 이해하고 신중하게 작성해야 한다.

비트 수준의 표현을 직접 조작하여 산술 연산을 수행하는 방법은 중요한 기술이며, 이는 컴파일러가 생성하는 기계 수준 코드를 이해하고 최적화하는 데 필수적이다. 숫자 표현과 산술 연산의 특성을 깊이 이해하고 이를 바탕으로 보안에 강하며 효율적인 프로그램을 작성하는 것은 프로그래머의 중요한 역할이다.

## 2.1 Information Storage
메모리에서 개별 비트에 접근하기보다는, 대부분의 컴퓨터는 **8비트 단위**, 즉 **바이트(byte)**를 메모리에 **가장 작은 주소 지정 가능 단위**로 사용한다. 메모리의 모든 바이트는 고유한 번호(주소)로 식별되며, 이러한 주소의 집합은 **가상 주소 공간(virtual address space)**이라고 불린다. 가상주소 공간은 기계 수준 프로그램에서 제공되는 개념적 이미지일 뿐이며, 실제 구현은 DRAM, 플래시 메모리, 디스크 저장소, 특수 하드웨어, 운영 체제의 소프트웨어의 조합을 통해 프로그램에 단일 바이트 처럼 보이도록 구성된다.

가상 주소 공간 내에서, 메모리는 프로그램 데이터, 명령어, 제어 정보와 같은 다양한 프로그램 객체를 저장하기 위해 더 작은 단위로 분할된다. 이러한 메모리 공간의 분할과 관리는 **컴파일러와 런타임 시스템**에 의해 수행된다. 예를 들어, C언어에서 포인터 값은 특정 데이터 유형(정수, 구조체, 기타 프로그램 객체 등)의 첫 번째 바이트의 가상 주소를 나타낸다.(포인터는 데이터가 시작하는 위치, 즉 첫 번째 바이트의 주소를 기리킴을 의미)

C컴파일러는 포인터마다 **데이터 타입 정보(type information)**를 연결하여, 포인터가 지정하는 위치에 저장된 값의 타입에 따라 적절한 기계 수준 코드를 생성한다. 하지만 실제로 생성된 기계 수준 프로그램은 데이터 타입에 대한 정보를 유지하지 않는다. 프로그램은 단순히 **바이트 블록으로 구성된 객체**와 **바이트 시퀀스로 이루어진 명령어**로 처리된다.

### 2.1.1 Hexadecimal Notation(16진수 표기법)

 - **1바이트(byte)**는 **8비트(bit)**로 구성되며, 값의 범위는 다음과 같다.
    - **이진수(Binary)** : 00000000 ~ 11111111
    - **십진수(Decimal)** : 0~255
    - **16진수(Hexadecimal)** : 00 ~ FF
 - 이진수는 표현이 너무 장황하고, 십진수는 비트 패턴과의 변환이 번거롭기 때문에, 이를 해결하기 위해 **16진수(hex)**를 사용한다.

 **16진수의 장점**
 - 이진수와 간단히 변환이 가능하다.
 - 이진수의 장황함을 줄이고, 십진수의 변환 복잡성을 해결한다.

 **C언어에서의 16진수 표기**
 - 0x or 0X로 시작
 - ex. 0xAB691 0Xab691 0xAb691 모두 동일하다.(대소문자 상관X)

 ![Alt text](/assets/images/16notation.png)

 **16진수 2진수 변환**
 - 16진수 한 자리(hex digit)는 **4개의 2진수 자리(bit)**로 변환된다. 즉, 16진수의 각 자리를 4비트 이진수로 확장하면 된다.
 
 ![Alt text](/assets/images/HexaToBi.png)

 **2진수 16진수 변환**
 - 2진수는 4비트씩 나누어 각 그룹을 16진수 숫자로 변환한다. 4비트로 나눌 때에는 오른쪽 부터 나누고, 가장 왼쪽의 비트 개수가 4개가 아니라면 0을 추가하여 4비트를 채워준다.

 ![Alt text](/assets/images/BiToHexa.png)

 - 만약 X(10진수 X)의 값이 **2의 거듭제곱** 꼴이라면, x = 2^n n을 4로 나눈 몫이 16진수의 0의 개수, 2의 "나머지"제곱이 16진수 가장 앞에 숫자가 된다.
 
    - x=2^11 //n=11
    - 11 = 3 + 4 x 2 이므로
    - 16진수 표기 : 0x800 (가장 앞 숫자 8은 2^3, 0의 개수는 2개)

 **10진수 16진수 변환**
 - 마찬가지로 10진수 값을 16으로 나눈 몫과 나머지로 표현 할 수 있다.

 ![Alt text](/assets//images/dectohex.png)

 314156의 hex 값은 : 0x4CB2C

 **16진수 10진수 변환**
 - 16진수 각 자리 숫자를 16의 적절한 거듭제곱으로 곱한 값을 모두 더하면 된다. 
 - 0xA7 의 경우 16^1 x 10(=A) + 16^0 x 7 = 167

 **16진수의 덧셈**
 1. 0x605c + 0x5 = 0x6061 // 5 + c -> 16(캐리 발생) + 1
 2. 0x605c - 0x20 = 0x603c
 3. 0x605c + 32 = 0x607c
 4. 0x60fa - 0x605c = 0x9e

### 2.1.2 Data Sizes
 컴퓨터의 **워드 크기(word size)**는 포인터 데이터의 명목 크기를 나타낸다. 가장 주소는 워드 크기로 인코딩되며, 워드 크기에 따라 가상 주소 공간의 최대 크기가 결정된다. 워드 크기가 w이면, 가상 주소 공간은 0부터 2^w-1 까지의 범위를 가지며, 이는 프로그램이 최대 2^w 바이트를 접근할 수 있음을 의미한다. 32비트 시스템은 최대 4GB의 주소 공간을 가지며, 64비트 시스템은 최대 16EB의 주소 공간을 갖는다.(워드는 CPU가 한번에 처리할 수 있는 data 크기를 의미하며, 32비트 시스템은 워드 크기가 32비트임을 의미한다.)

 대부분의 64비트 컴퓨터는 32비트 프로그램을 실행 가능하며(하위 호환성 제공), 반대는 불가능하다.

 C 언어의 데이터 타입 크기는 프로그램이 컴파일되는 환경에 따라 다르며, 아래 표는 각각의 일반적인 크기를 비교하기 위해 나타내고 있다. 

 ![Alt text](/assets/images/Cdatatypes.png)

 컴파일러 환경에 따라 데이터 타입이 달라지는 문제를 해결하기 위해 ISO C99는 고정 크기 데이터 타입을 도입하였다. 
    
    - int32_t : 정확히 4바이트
    - int64_t : 정확히 8바이트

 이를 사용하면 데이터 표현을 세밀하게 제어가 가능하다.
 
 대부분의 데이터 타입은 기본적으로 signed value(부호가 있는 값)으로 인코딩한다. 부호가 없는 값으로 처리를 하려면 Unsigned 키워드를 명시해줘야한다. 하지만 예외로 char가 있다. char는 C에서 부호의 존재를 보장하지않기 때문에 명시적 선언을 해주는 것이 안전하다.(보통 크게 중요하지않다.)

 대부분 두 가지 부동소수점 형식을 지원한다.
    
    - float(단정밀도, single precision) : 4bytes
    - double(배정밀도, double precision) : 8bytes

 포인터는 프로그램의 전체 워드 크기를 사용한다.
    
    - 32비트 시스템 : 4bytes
    - 64비트 시스템 : 8bytes

 C 표준은 다양한 데이터 타입의 숫자 범위에 대해서 상한을 설정해놓지 않았다.(고정 크기 제외) 이로 인해 다음과 같은 문제가 발생한다. 보통 32비트 체제에 맞춰 설계되었기 때문에 64비트 체제에서 버그가 발생한다. 예를 들어 과거에는 많은 프로그래머들이 int 타입으로 선언된 객체가 포인터를 저장하는 데 사용할 수 있다고 가정했다. 이는 대부분의 32비트 프로그램에서는 문제없이 작동하지만, 64비트 프로그램에서는 문제를 일으킨다.(64비트 환경에서는 포인터 크기가 더 크기 때문에, int 타입으로 이를 저장하려고 하면 상위 4바이트가 잘려나가면서 오류가 발생한다.) 즉, 64비트 환경에서는 포인터와 데이터 타입 크기를 명확히 구분하는 것이 중요하다. 

 즉, C 프로그래밍에서 워드 크기, 데이터 타입 크기, 포인터 처리 등은 하드웨어와 컴파일러 차이에 영향을 받는다. 이를 고려해 이식성이 높은 프로그램을 작성하려면 **고정 크기 데이터 타입 사용**, **포인터 크기와 데이터 타입 크기를 혼동하지 말 것**, **데이터 타입 선언 시 일관성을 유지할 것** 세 가지를 지키는 것이 좋다. (**데이터 타입 크기에 의존하지 않도록 설계하고 고정 크기 데이터 타입 사용을 권장한다.**)

## 2.2 Integer Representations
## 2.3 Integer Arithmetic
## 2.4 Floating Point
## 2.5 Summary